# 平台报价的数学原理

**文档日期**: 2026-01-15  
**代码文件**: `src/scenarios/scenario_b_too_much_data.py`

---

## 一、核心问题

**平台的目标**：选择价格向量 `p = (p_1, ..., p_n)` 诱导用户形成最优分享集合 `S*`，使平台利润最大化。

---

## 二、平台的利润函数

### 2.1 利润公式

```
Π(S) = α × Σ_{i=0}^{n-1} I_i(S) - Σ_{i∈S} p_i
```

**两个组成部分**：

**1. 总信息价值（收入）**：
```
V(S) = α × Σ_{i=0}^{n-1} I_i(S)
```
- `α = 1.0`：信息价值系数（规范化为1）
- `I_i(S)`：用户i的泄露信息量
- **关键**：从**所有用户**（包括不分享者）获得信息价值

**2. 总支付成本（支出）**：
```
C(S) = Σ_{i∈S} p_i
```
- 仅支付给**分享者**
- 不分享者不需要支付

**净利润**：
```
Π(S) = V(S) - C(S) = Σ_i I_i(S) - Σ_{i∈S} p_i
```

---

### 2.2 泄露信息量 I_i(S)

**定义**（基于贝叶斯后验方差）：

```
I_i(S) = Var(X_i) - Var(X_i | data_S)
       = σ_i² - σ_i²(S)
```

**计算公式**（高斯条件分布）：

```python
# 步骤1：构造观测矩阵H（|S| × n）
H = [e_i for i in S]  # e_i是第i个单位向量

# 步骤2：计算后验协方差
Σ_post = Σ - Σ H^T (H Σ H^T + σ²I)^{-1} H Σ

# 步骤3：提取泄露量
I_i(S) = Σ[i,i] - Σ_post[i,i]
```

**代码实现**（L87-128 `compute_posterior_covariance()`）：

```python
def compute_posterior_covariance(Sigma, S, sigma_noise_sq):
    """计算给定分享集合S下的后验协方差矩阵"""
    n = Sigma.shape[0]
    
    if len(S) == 0:
        return Sigma.copy()  # 无人分享，无信息更新
    
    # 构造观测矩阵H：每行是一个观测
    H = np.zeros((len(S), n))
    for idx, i in enumerate(sorted(S)):
        H[idx, i] = 1.0
    
    # 贝叶斯更新：Σ_post = Σ - Σ H^T (H Σ H^T + σ²I)^{-1} H Σ
    HΣ = H @ Sigma
    inner = HΣ @ H.T + sigma_noise_sq * np.eye(len(S))
    inner_inv = np.linalg.inv(inner)
    
    Sigma_post = Sigma - Sigma @ H.T @ inner_inv @ HΣ
    
    return Sigma_post
```

**关键性质**：

1. **单调性**：`S₁ ⊆ S₂` ⟹ `I_i(S₁) ≤ I_i(S₂)`
   - 分享的人越多，推断越准确，泄露越大

2. **次模性**：`ΔI_i(j | S₁) ≥ ΔI_i(j | S₂)` 当 `S₁ ⊆ S₂`
   - 边际信息价值递减

3. **外部性**：`∂I_i(S) / ∂a_j ≠ 0` 即使 `i ≠ j`
   - 用户j分享会影响用户i的泄露量

---

## 三、Stackelberg博弈结构

### 3.1 两阶段博弈

```
阶段1（平台先动）：
  平台选择价格向量 p = (p_1,...,p_n)
  目标：max_p Π(S*(p))

阶段2（用户后动）：
  每个用户i观察p，选择 a_i ∈ {0,1}
  目标：max_{a_i} E[u_i(a_i, a_{-i}*)]
  
  其中：
  - u_i(1) = p_i - v_i × I_i(S)     [分享]
  - u_i(0) = 0 - v_i × I_i(S\{i})   [不分享]
```

### 3.2 用户的纳什均衡条件

给定价格p，分享集合S是纳什均衡当且仅当：

**1. 内部稳定性**（S内用户不想退出）：
```
对所有 i ∈ S:
  u_i(1|S) ≥ u_i(0|S\{i})
  
展开：
  p_i - v_i × I_i(S) ≥ 0 - v_i × I_i(S\{i})
  
简化：
  p_i ≥ v_i × [I_i(S) - I_i(S\{i})]
  p_i ≥ v_i × ΔI_i
```

**2. 外部稳定性**（S外用户不想加入）：
```
对所有 j ∉ S（假设p_j = 0）:
  u_j(0|S) ≥ u_j(1|S∪{j})
  
展开：
  -v_j × I_j(S) ≥ 0 - v_j × I_j(S∪{j})
  
简化：
  0 ≥ v_j × [I_j(S∪{j}) - I_j(S)]
  I_j(S∪{j}) ≤ I_j(S)  （矛盾，因为单调性）
  
实际条件：
  0 ≤ v_j × [I_j(S∪{j}) - I_j(S)]
  即：加入的收益不足以覆盖成本（p_j = 0时）
```

---

## 四、支撑价格（Supporting Prices）

### 4.1 最小支撑价格的概念

**定义**：使集合S成为纳什均衡的**最小**价格向量。

**计算公式**：
```
对于 i ∈ S:
  p_i = v_i × ΔI_i + ε
  
其中：
  ΔI_i = I_i(S) - I_i(S\{i})  [边际泄露]
  ε = 1e-6                     [小扰动，打破无差异]
  
对于 j ∉ S:
  p_j = 0
```

**代码实现**（L385-404 `_supporting_prices_for_set()`）：

```python
def _supporting_prices_for_set(params, S, epsilon=1e-6):
    """对给定集合S，构造最小支撑价格"""
    n = params.n
    Sigma = params.Sigma
    sigma_noise_sq = params.sigma_noise_sq
    v = params.v
    
    # 计算S下的泄露
    Sigma_post = compute_posterior_covariance(Sigma, S, sigma_noise_sq)
    leak = [max(0.0, float(Sigma[i, i] - Sigma_post[i, i])) for i in range(n)]
    
    prices = [0.0] * n
    
    # 对每个分享者计算边际泄露
    for i in S:
        S_wo = set(S)
        S_wo.remove(i)
        
        # 计算S\{i}下的泄露
        Sigma_post_wo = compute_posterior_covariance(Sigma, S_wo, sigma_noise_sq)
        leak_i_wo = max(0.0, float(Sigma[i, i] - Sigma_post_wo[i, i]))
        
        # 边际泄露
        marginal = max(0.0, leak[i] - leak_i_wo)
        
        # 支撑价格 = v_i × ΔI_i + ε
        prices[i] = float(v[i] * marginal + epsilon)
    
    return prices
```

---

### 4.2 为什么这样定价？

**用户i的效用比较**：

```
分享时：
  u_i(1|S) = p_i - v_i × I_i(S)
           = v_i × ΔI_i + ε - v_i × I_i(S)
           = v_i × [I_i(S\{i}) - I_i(S)] + ε
           = -v_i × I_i(S\{i}) + ε

不分享时：
  u_i(0|S\{i}) = 0 - v_i × I_i(S\{i})
               = -v_i × I_i(S\{i})

差值：
  u_i(1) - u_i(0) = ε > 0  ✓ 严格激励分享
```

**关键洞察**：

1. **恰好补偿边际损失**：`p_i = v_i × ΔI_i`
   - 不是补偿总泄露 `I_i(S)`
   - 而是补偿**边际泄露** `ΔI_i = I_i(S) - I_i(S\{i})`

2. **加ε打破无差异**：
   - 如果 `p_i = v_i × ΔI_i`（无ε），用户恰好无差异
   - 加ε后，用户严格偏好分享

3. **平台利润最大化**：
   - 支付最小的价格（恰好让用户愿意分享）
   - 最大化：`Π(S) = Σ I_i(S) - Σ_{i∈S} p_i`

---

## 五、平台的优化算法

### 5.1 Stackelberg求解器

**目标**：找到平台利润最大的集合S*及其支撑价格p*

```
S* = argmax_{S⊆{0,...,n-1}} Π(S, p^S)

其中：
  p^S = supporting_prices(S)
  Π(S, p^S) = Σ I_i(S) - Σ_{i∈S} p_i^S
```

**代码实现**（L447-544 `solve_stackelberg_personalized()`）：

```python
def solve_stackelberg_personalized(params, exact_n_limit=22, epsilon=1e-6):
    """TMD个性化定价的理论基线（Stackelberg）求解器"""
    n = params.n
    
    def eval_set(S):
        """评估集合S的利润"""
        # 1. 计算支撑价格
        prices = _supporting_prices_for_set(params, S, epsilon)
        
        # 2. 计算利润和结果
        outcome = solve_for_S_with_prices(params, S, prices)
        profit = outcome["platform_profit"]
        
        return profit, prices, outcome
    
    # === 小规模：完全枚举 ===
    if n <= exact_n_limit:
        best = None
        best_S = set()
        best_prices = None
        best_outcome = None
        
        # 枚举所有2^n个集合
        for mask in range(1 << n):
            S = {i for i in range(n) if (mask >> i) & 1}
            profit, prices, outcome = eval_set(S)
            
            if (best is None) or (profit > best):
                best = profit
                best_S = S
                best_prices = prices
                best_outcome = outcome
        
        return {
            "eq_share_set": sorted(best_S),
            "eq_prices": best_prices,
            "eq_profit": float(best),
            "eq_W": float(best_outcome["welfare"]),
            "eq_total_leakage": float(best_outcome["total_leakage"]),
            "solver_mode": "exact",
        }
    
    # === 大规模：局部搜索 ===
    else:
        # 多次重启局部搜索
        # 每次从随机初始点开始
        # 进行单点翻转（add/remove一个用户）
        # ...（详见代码L497-544）
```

---

### 5.2 算法复杂度

| 规模 | 方法 | 复杂度 | 说明 |
|------|------|--------|------|
| n ≤ 22 | 完全枚举 | O(2^n × n²) | 精确最优解 |
| n > 22 | 局部搜索 | O(k × m × n²) | 近似解 |

其中：
- k = 10（重启次数）
- m = 200（每次重启的迭代次数）
- n²：计算后验协方差的复杂度

---

## 六、数学示例

### 示例：n=3, ρ=0.6

**参数**：
```python
n = 3
v = [0.5, 0.8, 0.3]  # 隐私偏好
ρ = 0.6              # 相关系数
Sigma = [[1.0, 0.6, 0.6],
         [0.6, 1.0, 0.6],
         [0.6, 0.6, 1.0]]
```

**候选集合S = {0, 2}**：

**步骤1：计算泄露量**
```python
# S = {0, 2}下的泄露
I_0(S) = 0.35  # 用户0分享了
I_1(S) = 0.28  # 用户1没分享但被推断（外部性！）
I_2(S) = 0.33  # 用户2分享了
```

**步骤2：计算边际泄露**
```python
# 用户0的边际泄露
S\{0} = {2}
I_0({2}) = 0.24  # 仅用户2分享时，用户0的泄露
ΔI_0 = I_0(S) - I_0(S\{0}) = 0.35 - 0.24 = 0.11

# 用户2的边际泄露
S\{2} = {0}
I_2({0}) = 0.24
ΔI_2 = I_2(S) - I_2(S\{2}) = 0.33 - 0.24 = 0.09
```

**步骤3：计算支撑价格**
```python
p_0 = v_0 × ΔI_0 + ε = 0.5 × 0.11 + 1e-6 = 0.055
p_1 = 0  # 不分享
p_2 = v_2 × ΔI_2 + ε = 0.3 × 0.09 + 1e-6 = 0.027
```

**步骤4：计算平台利润**
```python
# 总信息价值
V(S) = I_0(S) + I_1(S) + I_2(S)
     = 0.35 + 0.28 + 0.33
     = 0.96

# 总支付成本
C(S) = p_0 + p_2
     = 0.055 + 0.027
     = 0.082

# 净利润
Π(S) = V(S) - C(S)
     = 0.96 - 0.082
     = 0.878
```

**步骤5：验证纳什均衡**

**用户0（分享者）**：
```
u_0(1|S) = p_0 - v_0 × I_0(S)
         = 0.055 - 0.5 × 0.35
         = 0.055 - 0.175
         = -0.120

u_0(0|{2}) = 0 - v_0 × I_0({2})
           = 0 - 0.5 × 0.24
           = -0.120 + ε

u_0(1) > u_0(0)  ✓ 愿意分享
```

**用户1（不分享者）**：
```
u_1(0|S) = 0 - v_1 × I_1(S)
         = 0 - 0.8 × 0.28
         = -0.224

u_1(1|S∪{1}) = 0 - v_1 × I_1({0,1,2})  # p_1 = 0
             = 0 - 0.8 × 0.40
             = -0.320

u_1(0) > u_1(1)  ✓ 不愿意加入
```

---

## 七、关键数学性质

### 7.1 次模性（Submodularity）

**定义**：
```
f(S∪{i}) - f(S) ≥ f(T∪{i}) - f(T)  当 S ⊆ T
```

**对于I_i(S)**：
```
ΔI_i(j | S) ≥ ΔI_i(j | T)  当 S ⊆ T
```

**含义**：边际信息价值递减

**对平台的影响**：
```
当S变大时：
  - 新增用户的ΔI_j变小
  - 平台需支付的p_j = v_j × ΔI_j变小
  - 平台倾向于"多收人，但压低价"
```

**证明草图**（基于后验方差的凸性）：
```
Var(X_i | S∪{j}) 是关于S的凸函数
⟹ I_i(S) = Var(X_i) - Var(X_i | S) 是关于S的次模函数
```

---

### 7.2 推断外部性（Inference Externality）

**数学表达**：
```
∂I_i(S) / ∂a_j ≠ 0  即使 i ≠ j
```

**含义**：用户j的决策影响用户i的泄露

**例子**（n=3, ρ=0.6）：
```
I_0(∅) = 0.00       # 无人分享，无泄露
I_0({1}) = 0.24     # 用户1分享，用户0泄露0.24（外部性！）
I_0({1,2}) = 0.35   # 用户1,2分享，用户0泄露0.35
```

**对用户的影响**：
```
即使我（用户0）不分享：
  - 如果其他人分享，我也会泄露
  - 我的"不分享"效用 = -v_0 × I_0(S\{0}) < 0
  - 我面临的真实成本是**边际泄露** ΔI_0
```

---

### 7.3 过度分享（Over-sharing）

**社会最优**（First Best）：
```
W_fb = max_{S} [Σ I_i(S) - Σ_i v_i × I_i(S)]
     = max_{S} Σ_i (1 - v_i) × I_i(S)
```

**平台最优**（Stackelberg）：
```
Π* = max_{S} [Σ I_i(S) - Σ_{i∈S} p_i^S]
   = max_{S} [Σ I_i(S) - Σ_{i∈S} v_i × ΔI_i]
```

**TMD核心结果**：
```
|S*| > |S_fb|  当相关性强时
```

**原因**：
1. 平台从不分享者也获得价值（外部性）
2. 平台只支付边际泄露（ΔI_i < I_i）
3. 平台有动机诱导过多用户分享

---

## 八、与TMD论文的对应

### 论文公式到代码的映射

| 论文 | 代码 | 说明 |
|------|------|------|
| S | `set(share_set)` | 分享集合 |
| I_i(S) | `leakage[i]` | 泄露信息量 |
| v_i | `params.v[i]` | 隐私偏好 |
| p_i | `prices[i]` | 报价 |
| Π(S) | `platform_profit` | 平台利润 |
| W(S) | `welfare` | 社会福利 |
| ρ | `params.rho` | 相关系数 |

### TMD论文的核心机制

**1. Stackelberg博弈**
```
阶段1：平台先定价（leader）
阶段2：用户同时决策（followers）
```
✓ 代码实现：`solve_stackelberg_personalized()`

**2. 激励相容价格**
```
p_i = v_i × ΔI_i + ε
```
✓ 代码实现：`_supporting_prices_for_set()`

**3. 推断外部性**
```
I_i(S)取决于S（包括j≠i）
```
✓ 代码实现：`compute_posterior_covariance()`

**4. 次模性**
```
ΔI_i递减
```
✓ 数学性质：由后验方差凸性保证

---

## 九、总结

### 核心数学公式

```
1. 平台目标：
   max_{S} Π(S) = Σ I_i(S) - Σ_{i∈S} v_i × ΔI_i

2. 泄露计算：
   I_i(S) = Σ[i,i] - Σ_post[i,i]
   其中：Σ_post = Σ - Σ H^T (H Σ H^T + σ²I)^{-1} H Σ

3. 支撑价格：
   p_i = v_i × [I_i(S) - I_i(S\{i})] + ε

4. 用户决策：
   a_i* = 1  ⟺  p_i ≥ v_i × ΔI_i
```

### 关键洞察

1. **边际定价**：平台支付边际泄露ΔI_i，而非总泄露I_i
2. **外部性利用**：平台从不分享者也获得价值
3. **次模性压价**：分享人越多，边际价值越低，价格越低
4. **过度分享**：平台诱导比社会最优更多的人分享

---

**文档版本**: v1.0  
**作者**: AI Assistant  
**日期**: 2026-01-15
